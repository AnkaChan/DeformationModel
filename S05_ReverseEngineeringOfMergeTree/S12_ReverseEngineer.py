from M01_TopologicalExtraction import *
from M02_ScalarFieldInterpolation import *

if __name__ == '__main__':
    # data generated by ttk
    # inputScalarField = r'\Code\02_Graphics\DeformationModel\S05_ReverseEngineeringOfMergeTree\Data\S04_GenerateNewScalarField.py\M00000.obj'
    # inputScalarField = './Data/S04_GenerateNewScalarField.py/M00000.obj'
    # inputSegmentedField = './Data/S04_GenerateNewScalarField.py/Topology/M00000/Seg.vtk'
    # inputMergeTreeNodesField = './Data/S04_GenerateNewScalarField.py/Topology/M00000/Node.vtk'
    inputScalarField = './Data/S04_GenerateNewScalarField.py/M31562.obj'
    inputSegmentedField = './Data/S04_GenerateNewScalarField.py/Topology/M31562/Seg.vtk'
    inputMergeTreeNodesField = './Data/S04_GenerateNewScalarField.py/Topology/M31562/Node.vtk'
    inputMergeTreeEdges = './Data/S04_GenerateNewScalarField.py/Topology/M31562/Edges.vtk'

    # inputScalarField = './Data/S04_GenerateNewScalarField.py/M13338.obj'
    # inputSegmentedField = './Data/S04_GenerateNewScalarField.py/Topology/M13338/Seg1.vtk'
    # inputMergeTreeNodesField = './Data/S04_GenerateNewScalarField.py/Topology/M13338/Node1.vtk'
    gridSize = (200, 200)
    dType = np.float64
    P = sparse.load_npz('LaplacianMat.npz').astype(dType)
    print(P.shape)
    directions = [
        (-1, -1),
        (0, -1),
        (1, -1),
        (-1, 0),
        (1, 0),
        (-1, 1),
        (0, 1),
        (1, 1),
        (-2, -2),
        (0, -2),
        (2, -2),
        (-2, 0),
        (2, 0),
        (-2, 2),
        (0, 2),
        (2, 2),
        (-3, -3),
        (0, -3),
        (3, -3),
        (-3, 0),
        (3, 0),
        (-3, 3),
        (0, 3),
        (3, 3),
        (-4, -4),
        (0, -4),
        (4, -4),
        (-4, 0),
        (4, 0),
        (-4, 4),
        (0, 4),
        (4, 4),
    ]

    outFolder = r'./Data/' + os.path.basename(__file__) + '/M31562/'
    os.makedirs(outFolder, exist_ok=True)
    numberOfVariable = gridSize[0] * gridSize[1]

    fieldSeg = pv.read(inputSegmentedField)
    fieldSeg.points[:, 2] = fieldSeg['Height']
    fieldSeg.save(join(outFolder, 'ScalarFieldSimplified.vtk'))
    field = pv.PolyData(inputScalarField)
    # print(field.points[:, 0])
    print(min(field.points[:, 0]))
    print(max(field.points[:, 0]))
    print(min(field.points[:, 1]))
    print(max(field.points[:, 1]))

    nodes = pv.read(inputMergeTreeNodesField)
    edges = pv.read(inputMergeTreeEdges)
    contourLineHeight = findContourLineHeightBasedOnEdge(nodes, edges, fieldSeg, gridSize)

    tree = Tree()
    tree.load(inputMergeTreeNodesField, inputMergeTreeEdges, inputSegmentedField)

    # contourLineHeight2 = findContourLineHeight(nodes, fieldSeg, gridSize, directions)

    # print(fieldSeg.array_names)
    # print(fieldSeg.field_arrays["SegmentationId"])
    # fieldSeg["SegmentationId"]

    # find the contour line constraint
    # by iterating all the edges to find out the edge that cross two segmentations

    contourEdges, contourLineConstraintWeight, contourLineConstraintHeight = findContourLineConstraints(fieldSeg, gridSize, contourLineHeight)
    contourLinePoints = []

    # save and visualize contour line
    for edge, weights in zip(contourEdges, contourLineConstraintWeight):
        contourLinePoints.append(fieldSeg.points[edge[0],:]*weights[0] + fieldSeg.points[edge[1],:]*weights[1])

    contourLinePointsCloud = pv.PolyData()
    contourLinePointsCloud.points = np.array(contourLinePoints)
    contourLinePointsCloud.save(join(outFolder,'contourLine.ply'))

    # the boundary value constraints, keep boundary value as it is
    boundaryVerts = []
    boundaryVertsWeights = []
    boundaryVertsHeight = []
    for i in range(gridSize[0]):
        boundaryVerts.append([flatten2DIndex(i, 0, gridSize)])
        boundaryVertsWeights.append([1.])
        boundaryVertsHeight.append(fieldSeg["Height"][flatten2DIndex(i, 0, gridSize)])

        boundaryVerts.append([flatten2DIndex(i, gridSize[1]-1, gridSize)])
        boundaryVertsWeights.append([1.])
        boundaryVertsHeight.append(fieldSeg["Height"][flatten2DIndex(i, gridSize[1]-1, gridSize)])

    equalityConstraints = contourEdges + boundaryVerts
    equalityConstraintWeights = contourLineConstraintWeight + boundaryVertsWeights
    equalityConstraintVals = contourLineConstraintHeight + boundaryVertsHeight

    for j in range(1, gridSize[1]-1):
        boundaryVerts.append([flatten2DIndex(0, j, gridSize)])
        boundaryVertsWeights.append([1.])
        boundaryVertsHeight.append(fieldSeg["Height"][flatten2DIndex(0, j, gridSize)])

        boundaryVerts.append([flatten2DIndex(gridSize[0]-1, j, gridSize)])
        boundaryVertsWeights.append([1.])
        boundaryVertsHeight.append(fieldSeg["Height"][flatten2DIndex(gridSize[0]-1, j, gridSize)])

    # inequality constraints
    ## match critical points to grid verts
    iMeshVerts = matchTreeToGrid(nodes.points, fieldSeg.points)
    ## critical points
    inequalityConstraints = []
    inequalityConstraintWeights = []
    inequalityConstraintVals = []
    for i, vId in enumerate(iMeshVerts):
        ij = to2DIndex(vId,gridSize)
        # print(flatten2DIndex(ij[0], ij[1],gridSize))
        criticalType = nodes['CriticalType'][i]
        # equality constraints for extremity
        equalityConstraints.append([vId])
        equalityConstraintWeights.append([1.])
        equalityConstraintVals.append(nodes['Scalar'][i])
        if criticalType == 3:
            # 3: merge tree, local maximum
            for d in directions:
                neighborIj = (ij[0] + d[0], ij[1] + d[1])
                neighborVId = flatten2DIndex(neighborIj[0], neighborIj[1], gridSize)

                # inequality, larger than neighbors
                inequalityConstraints.append([vId, neighborVId, ])
                inequalityConstraintWeights.append([-1., 1.])
                inequalityConstraintVals.append(0.)

    Z = interpolateScalarField(gridSize, P, equalityConstraints, equalityConstraintWeights, equalityConstraintVals,
                               inequalityConstraints, inequalityConstraintWeights, inequalityConstraintVals,
                               fixBoundary=False)

    N = gridSize[1]
    X = np.linspace(min(field.points[:,0]), max(field.points[:,0]), N)
    Y = np.linspace(min(field.points[:,1]), max(field.points[:,1]), N)
    X, Y = np.meshgrid(X, Y)
    writeOBj(join(outFolder, 'result.obj'), X, Y, Z, gridSize)






